<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    
    <title>SHEIKO - Protocolo de Elite</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">
    <meta name="description" content="Calculadora de Carga e Aquecimento para Powerlifting e Musculação">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Versões estáveis e compatíveis -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;700;900&display=swap"
      rel="stylesheet"
    />

    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* Reset e otimizações para GPU e PWA */
      * {
        -webkit-tap-highlight-color: transparent;
      }
      body {
        font-family: 'Outfit', sans-serif;
        overscroll-behavior-y: none;
        overflow-x: hidden;
        background-color: #ffffff;
        /* Força aceleração de hardware e previne flickering */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Container principal com isolamento de contexto */
      #root {
        isolation: isolate; 
        width: 100%;
        min-height: 100vh;
      }
      
      /* Animação suave */
      .fade-in {
        animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
      }

      /* Utilitário para forçar nova camada de composição na GPU */
      .gpu-layer {
        transform: translateZ(0);
        backface-visibility: hidden;
        perspective: 1000px;
      }
    </style>
  </head>
  <body class="bg-white text-black min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
      // Registrar o plugin do Chart.js com segurança
      if (window.Chart && window.ChartDataLabels) {
        Chart.register(ChartDataLabels);
      }

      // --- ÍCONES ---
      const Dumbbell = ({ className, size = 24 }) => (
        <svg
          xmlns='http://www.w3.org/2000/svg'
          width={size}
          height={size}
          viewBox='0 0 24 24'
          fill='none'
          stroke='currentColor'
          strokeWidth='2'
          strokeLinecap='round'
          strokeLinejoin='round'
          className={className}
        >
          <path d='m6.5 6.5 11 11' />
          <path d='m21 21-1-1' />
          <path d='m3 3 1 1' />
          <path d='m18 22 4-4' />
          <path d='m2 6 4-4' />
          <path d='m3 10 7-7' />
          <path d='m14 21 7-7' />
        </svg>
      );

      const Calculator = ({ className, size = 24 }) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={size} 
          height={size} 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={className}
        >
          <rect width="16" height="20" x="4" y="2" rx="2"/>
          <line x1="8" x2="16" y1="6" y2="6"/>
          <line x1="16" x2="16" y1="14" y2="18"/>
          <path d="M16 10h.01"/>
          <path d="M12 10h.01"/>
          <path d="M8 10h.01"/>
          <path d="M12 14h.01"/>
          <path d="M8 14h.01"/>
          <path d="M12 18h.01"/>
          <path d="M8 18h.01"/>
        </svg>
      );
      const Fire = ({ className, size = 24 }) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width={size} 
          height={size} 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className={className}
        >
          <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3.7 2.5 2.2 4.8 2.9 6.8z"/>
        </svg>
      );
      const Check = ({ className, size = 24 }) => (
        <svg
          xmlns='http://www.w3.org/2000/svg'
          width={size}
          height={size}
          viewBox='0 0 24 24'
          fill='none'
          stroke='currentColor'
          strokeWidth='2'
          strokeLinecap='round'
          strokeLinejoin='round'
          className={className}
        >
          <polyline points='20 6 9 17 4 12' />
        </svg>
      );
      const Hash = ({ className, size = 24 }) => (
        <svg
          xmlns='http://www.w3.org/2000/svg'
          width={size}
          height={size}
          viewBox='0 0 24 24'
          fill='none'
          stroke='currentColor'
          strokeWidth='2'
          strokeLinecap='round'
          strokeLinejoin='round'
          className={className}
        >
          <line x1='4' x2='20' y1='9' y2='9' />
          <line x1='4' x2='20' y1='15' y2='15' />
          <line x1='10' x2='8' y1='3' y2='21' />
          <line x1='16' x2='14' y1='3' y2='21' />
        </svg>
      );
      const ArrowRight = ({ className, size = 24 }) => (
        <svg
          xmlns='http://www.w3.org/2000/svg'
          width={size}
          height={size}
          viewBox='0 0 24 24'
          fill='none'
          stroke='currentColor'
          strokeWidth='2'
          strokeLinecap='round'
          strokeLinejoin='round'
          className={className}
        >
          <path d='M5 12h14' />
          <path d='m12 5 7 7-7 7' />
        </svg>
      );
      const AlertCircle = ({ className, size = 24 }) => (
        <svg
          xmlns='http://www.w3.org/2000/svg'
          width={size}
          height={size}
          viewBox='0 0 24 24'
          fill='none'
          stroke='currentColor'
          strokeWidth='2'
          strokeLinecap='round'
          strokeLinejoin='round'
          className={className}
        >
          <circle cx='12' cy='12' r='10' />
          <line x1='12' x2='12' y1='8' y2='12' />
          <line x1='12' x2='12.01' y1='16' y2='16' />
        </svg>
      );

      // --- COMPONENTE DO GRÁFICO ---
      const WarmupChart = ({ sets, workLoad }) => {
        const chartRef = React.useRef(null);
        const chartInstance = React.useRef(null);

        React.useEffect(() => {
          if (!chartRef.current || sets.length === 0) return;

          const ctx = chartRef.current.getContext('2d');

          if (chartInstance.current) {
            chartInstance.current.destroy();
          }

          // Adicionar o Work Set aos dados do gráfico
          const chartDataSets = [
            ...sets,
            { weight: parseFloat(workLoad), percent: 100, isWorkSet: true }
          ];

          const labels = chartDataSets.map((_, i) => i === chartDataSets.length - 1 ? 'Work' : `Série ${i + 1}`);
          const data = chartDataSets.map((s) => s.weight);
          const percentages = chartDataSets.map((s) => s.percent + '%');

          const minWeight = Math.min(...data);
          const maxWeight = Math.max(...data);

          // Plugin Customizado
          const customDrawPlugin = {
            id: 'customDrawPlugin',
            afterDatasetsDraw: (chart) => {
              const { ctx, chartArea, scales: { x, y } } = chart;
              
              if (!chartArea) return;
              const { top, bottom, left, right } = chartArea;

              chart.data.datasets.forEach((dataset, i) => {
                 const meta = chart.getDatasetMeta(i);
                 if (!meta.hidden) {
                   meta.data.forEach((point, index) => {
                     if (
                        typeof point.x !== 'number' || isNaN(point.x) ||
                        typeof point.y !== 'number' || isNaN(point.y) ||
                        point.y > bottom || point.y < top ||
                        point.x < left || point.x > right
                     ) {
                       return;
                     }

                     ctx.save();
                     ctx.beginPath();
                     ctx.strokeStyle = '#CBD5E1'; 
                     ctx.lineWidth = 2;
                     ctx.setLineDash([0, 5]); 
                     ctx.lineCap = 'round';   
                     
                     ctx.moveTo(point.x, bottom);
                     ctx.lineTo(point.x, point.y);
                     ctx.stroke();
                     ctx.restore();
                   });
                 }
              });
            }
          };

          chartInstance.current = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Peso',
                  data: data,
                  borderColor: '#2563EB',
                  borderWidth: 1,
                  backgroundColor: (context) => {
                    const ctx = context.chart.ctx;
                    const gradient = ctx.createLinearGradient(0, 0, 0, 250);
                    gradient.addColorStop(0, 'rgba(37, 99, 235, 0.3)'); 
                    gradient.addColorStop(1, 'rgba(37, 99, 235, 0.0)');  
                    return gradient;
                  },
                  pointBackgroundColor: '#ffffff',
                  pointBorderColor: '#2563EB',
                  pointBorderWidth: 2,
                  
                  pointStyle: 'circle',

                  pointRadius: (ctx) => {
                    const index = ctx.dataIndex;
                    const count = ctx.dataset.data.length;
                    
                    if (index === 0 || index === count - 1) return 2;
                    return 1;
                  },
                  
                  pointHoverRadius: 6,
                  tension: 0.1,
                  fill: true,
                  clip: false, 
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: true, 
              layout: {
                padding: {
                  top: 40, 
                  right: 30, 
                  left: 30,  
                  bottom: 15
                }
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  backgroundColor: '#1F2937',
                  padding: 10,
                  titleFont: { family: 'Outfit', size: 12 },
                  bodyFont: { family: 'Outfit', size: 12, weight: 'bold' },
                  callbacks: {
                    label: (context) => `${context.raw}kg`,
                  },
                },
                datalabels: {
                  align: 'top',
                  anchor: 'end',
                  offset: 4,
                  backgroundColor: (context) => {
                    return context.dataIndex === context.dataset.data.length - 1 ? '#000000' : 'transparent';
                  },
                  borderColor: (context) => {
                    return context.dataIndex === context.dataset.data.length - 1 ? '#000000' : '#E5E7EB';
                  },
                  borderWidth: 1,
                  borderRadius: 4,
                  padding: { 
                    top: 2,
                    bottom: 2,
                    left: 4,
                    right: 4
                  },
                  color: (context) => {
                    return context.dataIndex === context.dataset.data.length - 1 ? '#FFFFFF' : '#6B7280';
                  },
                  font: {
                    family: 'Outfit',
                    weight: 'bold',
                    size: 9 
                  },
                  formatter: (value, context) => {
                    return percentages[context.dataIndex];
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: false,
                  min: minWeight,
                  max: maxWeight,
                  grid: {
                    display: true,
                    color: '#F3F4F6',
                    borderDash: [5, 5],
                    drawBorder: false,
                  },
                  ticks: { display: false },
                  border: { display: false }
                },
                x: {
                  grid: { display: false, drawBorder: false },
                  ticks: { display: false },
                  border: { display: false }
                },
              },
            },
            plugins: [customDrawPlugin]
          });

          return () => {
            if (chartInstance.current) {
              chartInstance.current.destroy();
            }
          };
        }, [sets, workLoad]);

        if (sets.length === 0) return null;

        return (
          <div className="w-full h-48 bg-white rounded-xl border border-gray-100 shadow-sm p-4 mb-6 relative gpu-layer">
             <div className="absolute top-4 left-4 z-10">
                <p className="text-xs font-bold text-gray-400 uppercase tracking-widest">Progressão de Carga</p>
             </div>
            <canvas ref={chartRef}></canvas>
          </div>
        );
      };

      // --- COMPONENTE: CALCULADORA 1RM ---
      const OneRepMaxCalc = ({ onCalculateWarmup }) => {
        const [oneRepMax, setOneRepMax] = React.useState('');

        const calculatePercentage = (percent) => {
          if (!oneRepMax) return 0;
          const rawWeight = parseFloat(oneRepMax) * (percent / 100);
          return Math.floor(rawWeight / 2) * 2;
        };

        const repRanges = [
          { reps: 5, percent: 75 },
          { reps: 8, percent: 65 },
          { reps: 12, percent: 55 },
          { reps: 15, percent: 50 },
        ];

        return (
          <div className="space-y-6 fade-in gpu-layer">
             <div className='mb-6'>
                <label className='block text-xs font-bold uppercase tracking-widest text-gray-400 mb-3'>
                  Seu 1RM (Repetição Máxima)
                </label>
                <div className='relative group'>
                  <input
                    type='number'
                    value={oneRepMax}
                    onChange={(e) => setOneRepMax(e.target.value)}
                    placeholder='0'
                    className='w-full text-6xl font-black border-b-4 border-gray-200 py-4 focus:outline-none focus:border-black transition-colors bg-transparent placeholder-gray-200'
                    step='any'
                  />
                  <span className='absolute right-0 top-1/2 -translate-y-1/2 text-xl font-bold text-gray-400 group-focus-within:text-black transition-colors'>
                    KG
                  </span>
                </div>
              </div>

              {oneRepMax > 0 && (
                <div className="grid grid-cols-1 gap-4">
                  {repRanges.map((range) => {
                    const weight = calculatePercentage(range.percent);
                    return (
                      <div key={range.reps} className="flex items-center justify-between p-4 bg-gray-50 rounded-xl border border-gray-100 hover:border-blue-200 transition-colors">
                        <div>
                          <div className="flex items-baseline gap-2">
                            <span className="text-3xl font-black text-gray-800">{weight}</span>
                            <span className="text-sm font-bold text-gray-400">kg</span>
                          </div>
                          <div className="text-xs font-bold uppercase tracking-widest text-blue-500 mt-1">
                            {range.reps} Repetições ({range.percent}%)
                          </div>
                        </div>
                        <button 
                          onClick={() => onCalculateWarmup(weight)}
                          className="bg-black text-white p-3 rounded-lg hover:bg-gray-800 transition-colors shadow-sm active:scale-95"
                        >
                          <ArrowRight size={20} />
                        </button>
                      </div>
                    )
                  })}
                </div>
              )}
          </div>
        );
      }

      // --- APLICATIVO SHEIKO ---
      const SheikoApp = () => {
        const [activeTab, setActiveTab] = React.useState('1rm'); 
        const [workLoad, setWorkLoad] = React.useState('');
        const [sets, setSets] = React.useState([]);
        const [completed, setCompleted] = React.useState([]);

        const roundToTen = (val) => Math.round(val / 10) * 10;
        const roundToFive = (val) => Math.round(val / 5) * 5;

        // Função para transição da Calc 1RM para Aquecimento
        const handleTransferWarmup = (weight) => {
          setWorkLoad(weight.toString());
          setActiveTab('warmup');
        };

        // --- LÓGICA DE CÁLCULO ---
        const calculateWarmup = (targetWeight) => {
          if (!targetWeight || targetWeight < 20) return [];

          const startWeight = 20;
          const isLowWeight = targetWeight < 80;

          if (targetWeight <= startWeight) {
             return [{
                weight: startWeight,
                reps: isLowWeight ? 5 : 10,
                percent: Math.round((startWeight / targetWeight) * 100)
             }];
          }

          let lastWarmup = roundToTen(targetWeight - 20);
          if ((targetWeight - lastWarmup) > 20) {
            lastWarmup = roundToTen(targetWeight - 10);
          }
          if (lastWarmup >= targetWeight) lastWarmup = targetWeight - 10;
          
          if (lastWarmup <= startWeight) {
             return [{
                weight: startWeight,
                reps: isLowWeight ? 5 : 10,
                percent: Math.round((startWeight / targetWeight) * 100)
             }];
          }

          const minSteps = isLowWeight ? 2 : 3; 

          let finalGap = targetWeight - lastWarmup;
          let range = lastWarmup - startWeight;
          
          let steps = Math.max(minSteps, Math.ceil(range / 40));
          let currentJump = range / steps;

          while (currentJump < finalGap && steps > 0) {
             let newLast = lastWarmup + 10;
             if (newLast >= targetWeight) break;

             lastWarmup = newLast;
             finalGap = targetWeight - lastWarmup;
             range = lastWarmup - startWeight;
             
             steps = Math.max(minSteps, Math.ceil(range / 40));
             currentJump = range / steps;
          }

          let warmupWeights = [];
          warmupWeights.push(startWeight);

          if (steps > 0) {
             const stepSize = range / steps;
             for (let i = 1; i <= steps; i++) {
                let val = startWeight + (stepSize * i);
                let rounded = roundToTen(val);
                
                if (i === steps) rounded = lastWarmup;

                if (targetWeight > 80 && rounded <= warmupWeights[warmupWeights.length - 1]) {
                    let fineRounded = roundToFive(val);
                    if (fineRounded > warmupWeights[warmupWeights.length - 1]) {
                        rounded = fineRounded;
                    } else {
                        if (i < steps) {
            